<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Valentine Puzzle</title>

  <style>
    :root{
      --pink1:#ff4d8d;
      --pink2:#ff7eb3;
      --soft:#fff5fa;

      --text:#5a0040;
      --muted:rgba(90,0,64,0.65);

      --card:rgba(255,255,255,0.70);
      --border:rgba(255,105,180,0.25);
      --shadow:0 25px 60px rgba(255,105,180,0.28);

      --trayW:66px;
      --trayH:110px;
    }

    html, body{ overscroll-behavior-y: none; }

    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:20px 0;
      color:var(--text);

      background:
        radial-gradient(circle at 18% 22%, rgba(255,255,255,0.35), transparent 40%),
        radial-gradient(circle at 82% 72%, rgba(255,255,255,0.35), transparent 42%),
        linear-gradient(135deg,var(--pink2),var(--pink1));
      touch-action: pan-y;
      overflow-x:hidden;
      position:relative;
    }

    /* soft hearts wallpaper */
    body::before{
      content:"‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§";
      position:fixed;
      inset:-40px;
      font-size:86px;
      line-height:1.9;
      letter-spacing:18px;
      color:rgba(255,255,255,0.08);
      display:flex;
      flex-wrap:wrap;
      align-content:center;
      justify-content:center;
      pointer-events:none;
      z-index:0;
      transform:rotate(-8deg);
    }

    /* floating hearts (stronger animation) */
    .float-hearts{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:1;
      overflow:hidden;
    }
    .heart{
      position:absolute;
      bottom:-60px;
      font-size:22px;
      opacity:0.20;
      color:rgba(255,255,255,0.95);
      text-shadow:0 10px 30px rgba(255,105,180,0.25);
      animation:
        rise var(--dur) linear var(--delay) infinite,
        sway var(--swayDur) ease-in-out var(--delay) infinite,
        twinkle var(--twDur) ease-in-out var(--delay) infinite;
      will-change: transform, opacity, filter;
      filter: blur(0.15px);
    }

    @keyframes rise{
      from{ transform: translateY(0) translateX(0) rotate(0deg) scale(var(--scale)); }
      to  { transform: translateY(-125vh) translateX(var(--drift)) rotate(var(--rot)) scale(calc(var(--scale) * 1.25)); }
    }
    @keyframes sway{
      0%,100%{ margin-left:0px; }
      50%{ margin-left:var(--sway); }
    }
    @keyframes twinkle{
      0%,100%{ opacity:0.10; filter:blur(0.2px); }
      50%{ opacity:0.35; filter:blur(0px); }
    }

    /* scroll allowed over board/tray, pieces handle drag */
    #board, #tray{ touch-action: pan-y; }
    .piece{ touch-action: none; }

    #confetti{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:9998;
    }

    .card{
      width:min(1040px,95vw);
      background:var(--card);
      backdrop-filter:blur(14px);
      border-radius:26px;
      padding:22px;
      border:1px solid var(--border);
      box-shadow:var(--shadow);
      box-sizing:border-box;
      z-index:2;
      position:relative;
    }

    .top{
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom:12px;
    }

    .brand{
      display:flex;
      gap:10px;
      align-items:center;
    }

    .badge{
      width:44px;height:44px;
      border-radius:16px;
      display:grid;place-items:center;
      background:rgba(255,77,141,0.16);
      border:1px solid rgba(255,77,141,0.25);
      box-shadow:0 10px 30px rgba(255,105,180,0.18);
      font-size:18px;
    }

    h1{
      margin:0 0 4px;
      font-size:22px;
      color:#b3005e;
      letter-spacing:0.2px;
    }
    p{ margin:0; color:var(--muted); line-height:1.6; }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin:12px 0 14px;
    }

    .btn{
      padding:10px 16px;
      border-radius:20px;
      font-weight:800;
      cursor:pointer;
      border:none;
      background:linear-gradient(135deg,var(--pink1),var(--pink2));
      color:white;
      box-shadow:0 10px 24px rgba(255,105,180,0.40);
      transition:transform .12s ease, box-shadow .2s ease, filter .2s ease;
    }
    .btn:hover{
      transform:translateY(-2px);
      box-shadow:0 14px 28px rgba(255,105,180,0.55);
      filter:saturate(1.05);
    }
    .btn:active{ transform:translateY(0); }

    .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:14px;
      align-items:start;
    }
    @media(max-width:860px){ .grid{ grid-template-columns:1fr; } }

    .panel{
      background:rgba(255,255,255,0.35);
      border:1px solid rgba(255,105,180,0.18);
      border-radius:20px;
      padding:12px;
      box-sizing:border-box;
    }

    .title{
      font-size:13px;
      color:rgba(90,0,64,0.70);
      margin:0 0 10px;
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    .progress{
      font-size:12px;
      color:rgba(90,0,64,0.65);
    }

    #board{
      position:relative;
      width:100%;
      aspect-ratio:9/16;
      border-radius:20px;
      overflow:hidden;
      background:white;
      border:2px solid rgba(255,105,180,0.30);
      box-shadow:0 14px 30px rgba(255,105,180,0.16);
    }

    #tray{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      min-height:120px;
      align-content:flex-start;
    }

    .piece{
      width:var(--trayW);
      height:var(--trayH);
      border-radius:18px;
      border:2px solid rgba(255,105,180,0.28);
      background-image:var(--img);
      background-size:var(--bgSize);
      background-position:var(--bgPos);
      cursor:grab;
      user-select:none;
      box-shadow:0 10px 22px rgba(255,105,180,0.22);
      transition:transform .12s ease, box-shadow .2s ease, border-color .2s ease;
    }
    .piece:hover{
      transform:translateY(-1px) scale(1.03);
      border-color:rgba(255,105,180,0.40);
      box-shadow:0 16px 30px rgba(255,105,180,0.28);
    }
    .piece:active{ cursor:grabbing; transform:scale(0.99); }

    /* ‚úÖ locked piece look */
    .piece.locked{
      cursor:default;
      box-shadow:0 10px 22px rgba(0,0,0,0.08);
      border-color:rgba(255,105,180,0.55);
      filter:saturate(1.05);
    }
    .piece.locked:hover{ transform:none; }

    .ghostSlot{
      position:absolute;
      border:1px dashed rgba(255,77,141,0.25);
      border-radius:14px;
      pointer-events:none;
    }

    .hint{
      margin-top:8px;
      font-size:13px;
      color:rgba(90,0,64,0.78);
      font-weight:800;
    }

    /* Envelope appears when fully solved */
    .envelopeWrap{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
      background:linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.25));
      backdrop-filter: blur(2px);
    }
    .envelopeWrap.show{ display:flex; }

    .envelopeBtn{
      border:none;
      cursor:pointer;
      background:rgba(255,255,255,0.80);
      border:2px solid rgba(255,105,180,0.35);
      border-radius:22px;
      padding:16px 18px;
      box-shadow:0 18px 40px rgba(255,105,180,0.30);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      transform:translateY(0);
      transition:transform .15s ease, box-shadow .2s ease;
    }
    .envelopeBtn:hover{
      transform:translateY(-3px);
      box-shadow:0 26px 55px rgba(255,105,180,0.38);
    }
    .envelopeIcon{
      width:88px;height:62px;
      border-radius:16px;
      position:relative;
      background:linear-gradient(135deg,#fff0f6,#ffe6f2);
      border:2px solid rgba(255,105,180,0.35);
      overflow:hidden;
    }
    .envelopeIcon::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        linear-gradient(135deg, transparent 48%, rgba(255,105,180,0.22) 49%, rgba(255,105,180,0.22) 51%, transparent 52%),
        linear-gradient(225deg, transparent 48%, rgba(255,105,180,0.22) 49%, rgba(255,105,180,0.22) 51%, transparent 52%);
      opacity:0.9;
    }
    .envelopeIcon::after{
      content:"‚ù§";
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-45%);
      color:rgba(179,0,94,0.85);
      font-size:20px;
      text-shadow:0 10px 20px rgba(255,105,180,0.25);
    }
    .envelopeText{
      font-weight:900;
      color:#b3005e;
      letter-spacing:0.2px;
    }
    .envelopeSub{
      font-size:12px;
      color:rgba(90,0,64,0.65);
      font-weight:800;
      margin-top:-6px;
    }

    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      background:rgba(255,105,180,0.20);
      backdrop-filter:blur(8px);
      z-index:9999;
    }
    .modal.open{ display:flex; }

    .modalCard{
      width:min(560px,92vw);
      background:linear-gradient(135deg,#fff0f6,#ffe6f2);
      border-radius:24px;
      padding:18px;
      border:1px solid rgba(255,105,180,0.30);
      box-shadow:0 22px 44px rgba(255,105,180,0.40);
    }

    .modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .modalTop h2{
      margin:0;
      font-size:16px;
      color:#b3005e;
      letter-spacing:0.2px;
    }

    .close{
      background:linear-gradient(135deg,var(--pink1),var(--pink2));
      border:none;
      color:white;
      border-radius:14px;
      padding:8px 12px;
      cursor:pointer;
      font-weight:900;
      box-shadow:0 10px 22px rgba(255,105,180,0.35);
    }

    .msg{
      white-space:pre-wrap;
      color:rgba(90,0,64,0.92);
      line-height:1.7;
      font-weight:750;
    }
  </style>
</head>

<body>
  <div class="float-hearts" aria-hidden="true" id="floatHearts"></div>
  <canvas id="confetti"></canvas>

  <div class="card">
    <div class="top">
      <div class="brand">
        <div class="badge">‚ù§</div>
        <div>
          <h1>Solve the puzzle üëáüèª ‚ô•Ô∏è</h1>
          <p></p>
        </div>
      </div>
    </div>

    <div class="row">
      <button class="btn" id="shuffleBtn">Shuffle</button>
      <button class="btn" id="restartBtn">Restart</button>
      <button class="btn" id="guideBtn">Toggle Guide</button>
    </div>

    <div class="grid">
      <div class="panel">
        <div class="title">
          <span>Board</span>
          <span class="progress" id="progress">0/16</span>
        </div>

        <div id="board">
          <div class="envelopeWrap" id="envelopeWrap">
            <button class="envelopeBtn" id="openLetterBtn" type="button">
              <div class="envelopeIcon"></div>
              <div class="envelopeText">Tap to open ‚ù§</div>
              <div class="envelopeSub">A little letter‚Ä¶</div>
            </button>
          </div>
        </div>

        <div class="hint" id="hint"></div>
      </div>

      <div class="panel">
        <div class="title"><span>Pieces tray</span></div>
        <div id="tray"></div>
      </div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="modalCard">
      <div class="modalTop">
        <h2>‚ù§</h2>
        <button class="close" id="closeModal">Close</button>
      </div>
      <div class="msg" id="modalMsg"></div>
    </div>
  </div>

<script>
  const IMAGE_SRC = "puzzle.jpg";
  const ROWS = 4;
  const COLS = 4;

  const finalMessage =
`Some sunsets are beautiful...
But you're my favourite sunset ‚ô•Ô∏è ‚ú®

Happy Valentine's Day my lovely Emy ‚ô•Ô∏è ‚ô•Ô∏è`;

  const board = document.getElementById("board");
  const tray = document.getElementById("tray");
  const hint = document.getElementById("hint");
  const progress = document.getElementById("progress");

  const envelopeWrap = document.getElementById("envelopeWrap");
  const openLetterBtn = document.getElementById("openLetterBtn");

  const modal = document.getElementById("modal");
  const modalMsg = document.getElementById("modalMsg");
  const closeModal = document.getElementById("closeModal");
  modalMsg.textContent = finalMessage;

  closeModal.addEventListener("click", () => modal.classList.remove("open"));
  modal.addEventListener("click", (e) => { if (e.target === modal) modal.classList.remove("open"); });

  const IMG = `url('${IMAGE_SRC}')`;

  let pieces = [];
  let showGuide = true;
  let confettiOnce = false;

  // prevent scroll/refresh only while dragging
  let isDragging = false;
  document.addEventListener("touchmove", (e) => {
    if (isDragging) e.preventDefault();
  }, { passive: false });

  function shuffle(arr){
    const a = [...arr];
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function clearAll(){
    // keep envelopeWrap element (already inside board)
    [...board.querySelectorAll(".ghostSlot")].forEach(x => x.remove());
    [...board.querySelectorAll(".piece")].forEach(x => x.remove());
    tray.innerHTML = "";
    pieces = [];
    envelopeWrap.classList.remove("show");
    modal.classList.remove("open");
    confettiOnce = false;
  }

  function makeSlots(){
    const rect = board.getBoundingClientRect();
    const slotW = rect.width / COLS;
    const slotH = rect.height / ROWS;

    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const s = document.createElement("div");
        s.className = "ghostSlot";
        s.style.left = (c*slotW) + "px";
        s.style.top  = (r*slotH) + "px";
        s.style.width  = slotW + "px";
        s.style.height = slotH + "px";
        s.style.opacity = showGuide ? "1" : "0";
        board.appendChild(s);
      }
    }
  }

  function updateTrayPieceSize(){
    const boardRect = board.getBoundingClientRect();
    const slotW = boardRect.width / COLS;
    const slotH = boardRect.height / ROWS;

    const scale = 0.58;
    const trayW = Math.max(48, Math.floor(slotW * scale));
    const trayH = Math.max(70, Math.floor(slotH * scale));

    document.documentElement.style.setProperty("--trayW", trayW + "px");
    document.documentElement.style.setProperty("--trayH", trayH + "px");
  }

  function createPieces(){
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const correctIdx = r*COLS + c;
        const d = document.createElement("div");
        d.className = "piece";
        d.dataset.correct = String(correctIdx);
        d.dataset.placed = "0";
        d.dataset.locked = "0";
        d.style.setProperty("--img", IMG);
        d.style.setProperty("--bgSize", `${COLS*100}% ${ROWS*100}%`);

        const posX = (c/(COLS-1||1))*100;
        const posY = (r/(ROWS-1||1))*100;
        d.style.setProperty("--bgPos", `${posX}% ${posY}%`);

        pieces.push(d);
      }
    }

    pieces = shuffle(pieces);
    pieces.forEach(p => tray.appendChild(p));
    attachDrag();
    updateProgress();
    hint.textContent = "Start ‚ù§";
  }

  function placedCount(){
    return board.querySelectorAll(".piece").length;
  }

  function updateProgress(){
    const placed = placedCount();
    progress.textContent = `${placed}/${ROWS*COLS}`;
  }

  function isLocked(el){ return el && el.dataset && el.dataset.locked === "1"; }

  function checkSolved(){
    updateProgress();

    const placed = [...board.querySelectorAll(".piece")];
    if (placed.length !== ROWS*COLS){
      hint.textContent = `Placed ${placed.length}/${ROWS*COLS}`;
      envelopeWrap.classList.remove("show");
      return;
    }

    let ok = true;
    for (const p of placed){
      const correct = parseInt(p.dataset.correct, 10);
      const slot = parseInt(p.dataset.slot, 10);
      if (correct !== slot){ ok = false; break; }
    }

    if (ok){
      hint.textContent = "Perfect ‚ù§";
      envelopeWrap.classList.add("show");
    } else {
      hint.textContent = "Almost‚Ä¶ ‚ù§";
      envelopeWrap.classList.remove("show");
      modal.classList.remove("open");
    }
  }

  function shuffleTray(){
    const unplaced = [...tray.querySelectorAll(".piece")].filter(p => p.dataset.locked !== "1");
    const s = shuffle(unplaced);
    // keep locked (shouldn't exist in tray, but just in case)
    const lockedInTray = [...tray.querySelectorAll(".piece")].filter(p => p.dataset.locked === "1");
    tray.innerHTML = "";
    lockedInTray.forEach(x => tray.appendChild(x));
    s.forEach(x => tray.appendChild(x));
  }

  function attachDrag(){
    pieces.forEach(p => {
      if (p.dataset.dragBound === "1") return;
      p.dataset.dragBound = "1";

      p.addEventListener("pointerdown", (e) => {
        // ‚úÖ locked piece: don't move
        if (p.dataset.locked === "1") return;

        e.preventDefault();
        p.setPointerCapture(e.pointerId);
        isDragging = true;

        const startedInBoard = (p.dataset.placed === "1");
        const fromSlot = startedInBoard ? parseInt(p.dataset.slot, 10) : null;

        const startX = e.clientX, startY = e.clientY;
        const origRect = p.getBoundingClientRect();

        p.style.visibility = "hidden";

        const clone = p.cloneNode(true);
        clone.classList.remove("locked");
        clone.style.position = "fixed";
        clone.style.left = origRect.left + "px";
        clone.style.top = origRect.top + "px";
        clone.style.width = origRect.width + "px";
        clone.style.height = origRect.height + "px";
        clone.style.margin = "0";
        clone.style.zIndex = "9997";
        clone.style.opacity = "0.95";
        clone.style.cursor = "grabbing";
        document.body.appendChild(clone);

        const endDrag = () => { isDragging = false; };

        const move = (ev) => {
          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          clone.style.transform = `translate(${dx}px, ${dy}px)`;
        };

        const snapPieceToSlot = (pieceEl, targetIdx) => {
          const boardRect = board.getBoundingClientRect();
          const slotW = boardRect.width / COLS;
          const slotH = boardRect.height / ROWS;
          const r = Math.floor(targetIdx / COLS);
          const c = targetIdx % COLS;

          pieceEl.dataset.slot = String(targetIdx);
          pieceEl.dataset.placed = "1";

          pieceEl.style.position = "absolute";
          pieceEl.style.left = (c*slotW) + "px";
          pieceEl.style.top  = (r*slotH) + "px";
          pieceEl.style.width  = slotW + "px";
          pieceEl.style.height = slotH + "px";
          pieceEl.style.borderRadius = "14px";
          pieceEl.style.cursor = (pieceEl.dataset.locked === "1") ? "default" : "grab";
          pieceEl.style.visibility = "";

          board.appendChild(pieceEl);
        };

        const returnToOrigin = () => {
          // if it started in board, return to its old slot; else to tray
          if (startedInBoard && fromSlot !== null){
            snapPieceToSlot(p, fromSlot);
          } else {
            p.dataset.placed = "0";
            p.removeAttribute("data-slot");
            p.style.position = "";
            p.style.left = "";
            p.style.top = "";
            p.style.width = "";
            p.style.height = "";
            p.style.cursor = "grab";
            p.style.visibility = "";
            tray.appendChild(p);
          }
          modal.classList.remove("open");
          checkSolved();
        };

        const dropIntoTray = () => {
          // if piece was locked (shouldn't happen), refuse
          if (p.dataset.locked === "1"){ returnToOrigin(); return; }

          p.dataset.placed = "0";
          p.removeAttribute("data-slot");
          p.style.position = "";
          p.style.left = "";
          p.style.top = "";
          p.style.width = "";
          p.style.height = "";
          p.style.cursor = "grab";
          p.style.visibility = "";
          tray.appendChild(p);
          modal.classList.remove("open");
          checkSolved();
        };

        const lockIfCorrect = (pieceEl) => {
          const correct = parseInt(pieceEl.dataset.correct, 10);
          const slot = parseInt(pieceEl.dataset.slot, 10);
          if (correct === slot){
            pieceEl.dataset.locked = "1";
            pieceEl.classList.add("locked");
            pieceEl.style.cursor = "default";
          }
        };

        const up = (ev) => {
          p.releasePointerCapture(e.pointerId);
          window.removeEventListener("pointermove", move);
          window.removeEventListener("pointerup", up);

          const boardRect = board.getBoundingClientRect();
          const dropX = ev.clientX, dropY = ev.clientY;

          const onBoard =
            dropX >= boardRect.left && dropX <= boardRect.right &&
            dropY >= boardRect.top  && dropY <= boardRect.bottom;

          if (!onBoard){
            clone.remove();
            dropIntoTray();
            endDrag();
            return;
          }

          const localX = dropX - boardRect.left;
          const localY = dropY - boardRect.top;

          const slotW = boardRect.width / COLS;
          const slotH = boardRect.height / ROWS;

          const c = Math.max(0, Math.min(COLS-1, Math.floor(localX / slotW)));
          const r = Math.max(0, Math.min(ROWS-1, Math.floor(localY / slotH)));
          const targetIdx = r*COLS + c;

          const occupant = board.querySelector(`.piece[data-slot='${targetIdx}']`);

          // ‚úÖ if target slot has locked piece -> cancel drop
          if (isLocked(occupant)){
            clone.remove();
            p.style.visibility = "";
            returnToOrigin();
            endDrag();
            return;
          }

          // if target occupied by movable piece, swap logic
          if (occupant && occupant !== p){
            // if dragged piece started on board: try move occupant back to fromSlot (only if fromSlot exists and not locked)
            if (startedInBoard && fromSlot !== null && fromSlot !== targetIdx){
              const backOcc = board.querySelector(`.piece[data-slot='${fromSlot}']`);
              if (!backOcc){
                snapPieceToSlot(occupant, fromSlot);
              } else {
                // if back slot occupied, send occupant to tray (only if it's not locked)
                if (!isLocked(occupant)){
                  occupant.dataset.placed = "0";
                  occupant.removeAttribute("data-slot");
                  occupant.style.position = "";
                  occupant.style.left = "";
                  occupant.style.top = "";
                  occupant.style.width = "";
                  occupant.style.height = "";
                  occupant.style.cursor = "grab";
                  tray.appendChild(occupant);
                }
              }
            } else {
              // dragged from tray: move occupant to tray
              if (!isLocked(occupant)){
                occupant.dataset.placed = "0";
                occupant.removeAttribute("data-slot");
                occupant.style.position = "";
                occupant.style.left = "";
                occupant.style.top = "";
                occupant.style.width = "";
                occupant.style.height = "";
                occupant.style.cursor = "grab";
                tray.appendChild(occupant);
              }
            }
          }

          snapPieceToSlot(p, targetIdx);
          lockIfCorrect(p);

          clone.remove();
          modal.classList.remove("open");
          checkSolved();
          endDrag();
        };

        window.addEventListener("pointermove", move);
        window.addEventListener("pointerup", up);
      });
    });
  }

  // Confetti
  const confettiCanvas = document.getElementById("confetti");
  const ctx = confettiCanvas.getContext("2d");
  let confetti = [];
  let confettiRunning = false;

  function resizeConfetti(){
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resizeConfetti);
  resizeConfetti();

  function startConfetti(){
    if (confettiRunning) return;
    confettiRunning = true;

    confetti = Array.from({length: 180}, () => ({
      x: Math.random()*confettiCanvas.width,
      y: -20 - Math.random()*confettiCanvas.height*0.3,
      s: 3 + Math.random()*4,
      vy: 2 + Math.random()*4,
      vx: -1 + Math.random()*2,
      a: Math.random()*Math.PI*2,
      va: -0.12 + Math.random()*0.24,
      life: 170 + Math.random()*130
    }));

    requestAnimationFrame(tickConfetti);
    setTimeout(() => { confettiRunning = false; }, 2400);
  }

  function tickConfetti(){
    ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);

    for (const p of confetti){
      p.x += p.vx;
      p.y += p.vy;
      p.a += p.va;
      p.life -= 1;

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.a);

      const hue = 320 + Math.floor(Math.random()*45);
      ctx.fillStyle = `hsla(${hue}, 90%, 70%, 0.9)`;
      ctx.fillRect(-p.s, -p.s, p.s*2, p.s*2);

      ctx.restore();
    }

    confetti = confetti.filter(p => p.life > 0 && p.y < confettiCanvas.height + 40);

    if (confettiRunning || confetti.length){
      requestAnimationFrame(tickConfetti);
    } else {
      ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
    }
  }

  // Floating hearts generator (hearts only)
  const floatHearts = document.getElementById("floatHearts");
  const COUNT = 34;
  for(let i=0;i<COUNT;i++){
    const h = document.createElement("div");
    h.className = "heart";
    h.textContent = "‚ù§";

    const left = Math.random()*100;
    const dur = 7.5 + Math.random()*10.5;
    const delay = Math.random()*6;
    const scale = 0.55 + Math.random()*1.2;
    const drift = (Math.random()*120 - 60).toFixed(0) + "px";
    const rot = (Math.random()*260 - 130).toFixed(0) + "deg";
    const sway = (Math.random()*26 - 13).toFixed(0) + "px";
    const swayDur = (2.8 + Math.random()*3.2).toFixed(1) + "s";
    const twDur = (2.0 + Math.random()*3.5).toFixed(1) + "s";
    const size = (18 + Math.random()*34).toFixed(0) + "px";
    const opacity = (0.10 + Math.random()*0.22).toFixed(2);

    h.style.left = left + "vw";
    h.style.setProperty("--dur", dur.toFixed(1) + "s");
    h.style.setProperty("--delay", delay.toFixed(1) + "s");
    h.style.setProperty("--scale", scale.toFixed(2));
    h.style.setProperty("--drift", drift);
    h.style.setProperty("--rot", rot);
    h.style.setProperty("--sway", sway);
    h.style.setProperty("--swayDur", swayDur);
    h.style.setProperty("--twDur", twDur);
    h.style.fontSize = size;
    h.style.opacity = opacity;

    floatHearts.appendChild(h);
  }

  document.getElementById("shuffleBtn").addEventListener("click", shuffleTray);
  document.getElementById("restartBtn").addEventListener("click", init);
  document.getElementById("guideBtn").addEventListener("click", () => {
    showGuide = !showGuide;
    [...board.querySelectorAll(".ghostSlot")].forEach(s => s.style.opacity = showGuide ? "1" : "0");
  });

  openLetterBtn.addEventListener("click", () => {
    modal.classList.add("open");
    if (!confettiOnce){
      confettiOnce = true;
      startConfetti();
    }
  });

  function init(){
    clearAll();
    makeSlots();
    updateTrayPieceSize();
    createPieces();
  }

  const preload = new Image();
  preload.onload = () => init();
  preload.onerror = () => {
    hint.textContent = "Image not loading. Ensure it's named puzzle.jpg and in the same folder as index.html.";
  };
  preload.src = IMAGE_SRC;
</script>
</body>
</html>
