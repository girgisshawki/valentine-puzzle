<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Valentine Puzzle</title>

  <style>
    :root{
      --pink1:#ff4d8d;
      --pink2:#ff7eb3;
      --pink3:#ffd6e8;
      --soft:#fff5fa;

      --text:#5a0040;
      --muted:rgba(90,0,64,0.65);

      --card:rgba(255,255,255,0.70);
      --border:rgba(255,105,180,0.25);
      --shadow:0 25px 60px rgba(255,105,180,0.28);

      --trayW:66px;
      --trayH:110px;
    }

    html, body{
      overscroll-behavior-y: none;
    }

    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:20px 0;
      color:var(--text);

      background:
        radial-gradient(circle at 18% 22%, rgba(255,255,255,0.35), transparent 40%),
        radial-gradient(circle at 82% 72%, rgba(255,255,255,0.35), transparent 42%),
        linear-gradient(135deg,var(--pink2),var(--pink1));
      touch-action: pan-y;
      overflow-x:hidden;
      position:relative;
    }

    /* soft hearts pattern */
    body::before{
      content:"‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§ ‚ù§";
      position:fixed;
      inset:-40px;
      font-size:84px;
      line-height:1.9;
      letter-spacing:20px;
      color:rgba(255,255,255,0.08);
      display:flex;
      flex-wrap:wrap;
      align-content:center;
      justify-content:center;
      pointer-events:none;
      z-index:0;
      transform:rotate(-8deg);
    }

    /* floating hearts */
    .float-hearts{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:1;
      overflow:hidden;
    }
    .heart{
      position:absolute;
      bottom:-40px;
      font-size:22px;
      opacity:0.25;
      animation: rise linear infinite;
      filter: blur(0.2px);
    }
    @keyframes rise{
      from{ transform: translateY(0) translateX(0) scale(1); }
      to{ transform: translateY(-120vh) translateX(-30px) scale(1.25); }
    }

    /* scroll allowed over board/tray, pieces handle drag */
    #board, #tray{ touch-action: pan-y; }
    .piece{ touch-action: none; }

    #confetti{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:9998;
    }

    .card{
      width:min(1040px,95vw);
      background:var(--card);
      backdrop-filter:blur(14px);
      border-radius:26px;
      padding:22px;
      border:1px solid var(--border);
      box-shadow:var(--shadow);
      box-sizing:border-box;
      z-index:2;
      position:relative;
    }

    .top{
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom:12px;
    }

    .brand{
      display:flex;
      gap:10px;
      align-items:center;
    }

    .badge{
      width:44px;height:44px;
      border-radius:16px;
      display:grid;place-items:center;
      background:rgba(255,77,141,0.16);
      border:1px solid rgba(255,77,141,0.25);
      box-shadow:0 10px 30px rgba(255,105,180,0.18);
      font-size:18px;
    }

    h1{
      margin:0 0 4px;
      font-size:22px;
      color:#b3005e;
      letter-spacing:0.2px;
    }
    p{
      margin:0;
      color:var(--muted);
      line-height:1.6;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin:12px 0 14px;
    }

    .btn{
      padding:10px 16px;
      border-radius:20px;
      font-weight:800;
      cursor:pointer;
      border:none;
      background:linear-gradient(135deg,var(--pink1),var(--pink2));
      color:white;
      box-shadow:0 10px 24px rgba(255,105,180,0.40);
      transition:transform .12s ease, box-shadow .2s ease, filter .2s ease;
    }
    .btn:hover{
      transform:translateY(-2px);
      box-shadow:0 14px 28px rgba(255,105,180,0.55);
      filter:saturate(1.05);
    }
    .btn:active{ transform:translateY(0); }

    .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:14px;
      align-items:start;
    }
    @media(max-width:860px){ .grid{ grid-template-columns:1fr; } }

    .panel{
      background:rgba(255,255,255,0.35);
      border:1px solid rgba(255,105,180,0.18);
      border-radius:20px;
      padding:12px;
      box-sizing:border-box;
    }

    .title{
      font-size:13px;
      color:rgba(90,0,64,0.70);
      margin:0 0 10px;
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    .progress{
      font-size:12px;
      color:rgba(90,0,64,0.65);
    }

    #board{
      position:relative;
      width:100%;
      aspect-ratio:9/16;
      border-radius:20px;
      overflow:hidden;
      background:white;
      border:2px solid rgba(255,105,180,0.30);
      box-shadow:0 14px 30px rgba(255,105,180,0.16);
    }

    #tray{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      min-height:120px;
      align-content:flex-start;
    }

    .piece{
      width:var(--trayW);
      height:var(--trayH);
      border-radius:18px;
      border:2px solid rgba(255,105,180,0.28);
      background-image:var(--img);
      background-size:var(--bgSize);
      background-position:var(--bgPos);
      cursor:grab;
      user-select:none;
      box-shadow:0 10px 22px rgba(255,105,180,0.22);
      transition:transform .12s ease, box-shadow .2s ease, border-color .2s ease;
    }
    .piece:hover{
      transform:translateY(-1px) scale(1.03);
      border-color:rgba(255,105,180,0.40);
      box-shadow:0 16px 30px rgba(255,105,180,0.28);
    }
    .piece:active{ cursor:grabbing; transform:scale(0.99); }

    .ghostSlot{
      position:absolute;
      border:1px dashed rgba(255,77,141,0.25);
      border-radius:14px;
      pointer-events:none;
    }

    .hint{
      margin-top:8px;
      font-size:13px;
      color:rgba(90,0,64,0.78);
      font-weight:700;
    }

    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      background:rgba(255,105,180,0.20);
      backdrop-filter:blur(8px);
      z-index:9999;
    }
    .modal.open{ display:flex; }

    .modalCard{
      width:min(560px,92vw);
      background:linear-gradient(135deg,#fff0f6,#ffe6f2);
      border-radius:24px;
      padding:18px;
      border:1px solid rgba(255,105,180,0.30);
      box-shadow:0 22px 44px rgba(255,105,180,0.40);
    }

    .modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .modalTop h2{
      margin:0;
      font-size:16px;
      color:#b3005e;
      letter-spacing:0.2px;
    }

    .close{
      background:linear-gradient(135deg,var(--pink1),var(--pink2));
      border:none;
      color:white;
      border-radius:14px;
      padding:8px 12px;
      cursor:pointer;
      font-weight:900;
      box-shadow:0 10px 22px rgba(255,105,180,0.35);
    }

    .msg{
      white-space:pre-wrap;
      color:rgba(90,0,64,0.92);
      line-height:1.7;
      font-weight:650;
    }
  </style>
</head>

<body>
  <div class="float-hearts" aria-hidden="true" id="floatHearts"></div>
  <canvas id="confetti"></canvas>

  <div class="card">
    <div class="top">
      <div class="brand">
        <div class="badge">üíò</div>
        <div>
          <h1>Solve the puzzle üëáüèª ‚ô•Ô∏è</h1>
          <p></p>
        </div>
      </div>
    </div>

    <div class="row">
      <button class="btn" id="shuffleBtn">Shuffle</button>
      <button class="btn" id="restartBtn">Restart</button>
      <button class="btn" id="guideBtn">Toggle Guide</button>
    </div>

    <div class="grid">
      <div class="panel">
        <div class="title">
          <span>Board</span>
          <span class="progress" id="progress">0/16</span>
        </div>
        <div id="board"></div>
        <div class="hint" id="hint"></div>
      </div>

      <div class="panel">
        <div class="title"><span>Pieces tray</span></div>
        <div id="tray"></div>
      </div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="modalCard">
      <div class="modalTop">
        <h2>Unlocked üíå</h2>
        <button class="close" id="closeModal">Close</button>
      </div>
      <div class="msg" id="modalMsg"></div>
    </div>
  </div>

<script>
  const IMAGE_SRC = "puzzle.jpg";
  const ROWS = 4;
  const COLS = 4;

  const finalMessage =
`Happy Valentine‚Äôs Day, Emily üåπ

Some sunsets are beautiful‚Ä¶
but this one is yours.

‚Äî Girgis`;

  const board = document.getElementById("board");
  const tray = document.getElementById("tray");
  const hint = document.getElementById("hint");
  const progress = document.getElementById("progress");

  const modal = document.getElementById("modal");
  const modalMsg = document.getElementById("modalMsg");
  const closeModal = document.getElementById("closeModal");
  modalMsg.textContent = finalMessage;

  closeModal.addEventListener("click", () => modal.classList.remove("open"));
  modal.addEventListener("click", (e) => { if (e.target === modal) modal.classList.remove("open"); });

  const IMG = `url('${IMAGE_SRC}')`;

  let pieces = [];
  let showGuide = true;
  let solvedOnce = false;

  // prevent scroll/refresh only while dragging
  let isDragging = false;
  document.addEventListener("touchmove", (e) => {
    if (isDragging) e.preventDefault();
  }, { passive: false });

  function shuffle(arr){
    const a = [...arr];
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function clearAll(){
    board.innerHTML = "";
    tray.innerHTML = "";
    pieces = [];
    modal.classList.remove("open");
    solvedOnce = false;
  }

  function makeSlots(){
    const rect = board.getBoundingClientRect();
    const slotW = rect.width / COLS;
    const slotH = rect.height / ROWS;

    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const s = document.createElement("div");
        s.className = "ghostSlot";
        s.style.left = (c*slotW) + "px";
        s.style.top  = (r*slotH) + "px";
        s.style.width  = slotW + "px";
        s.style.height = slotH + "px";
        s.style.opacity = showGuide ? "1" : "0";
        board.appendChild(s);
      }
    }
  }

  function updateTrayPieceSize(){
    const boardRect = board.getBoundingClientRect();
    const slotW = boardRect.width / COLS;
    const slotH = boardRect.height / ROWS;

    const scale = 0.58;
    const trayW = Math.max(48, Math.floor(slotW * scale));
    const trayH = Math.max(70, Math.floor(slotH * scale));

    document.documentElement.style.setProperty("--trayW", trayW + "px");
    document.documentElement.style.setProperty("--trayH", trayH + "px");
  }

  function createPieces(){
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const correctIdx = r*COLS + c;
        const d = document.createElement("div");
        d.className = "piece";
        d.dataset.correct = String(correctIdx);
        d.dataset.placed = "0";
        d.style.setProperty("--img", IMG);
        d.style.setProperty("--bgSize", `${COLS*100}% ${ROWS*100}%`);

        const posX = (c/(COLS-1||1))*100;
        const posY = (r/(ROWS-1||1))*100;
        d.style.setProperty("--bgPos", `${posX}% ${posY}%`);

        pieces.push(d);
      }
    }

    pieces = shuffle(pieces);
    pieces.forEach(p => tray.appendChild(p));
    attachDrag();
    updateProgress();
    hint.textContent = "Start üôÇ";
  }

  function placedCount(){
    return board.querySelectorAll(".piece").length;
  }

  function updateProgress(){
    const placed = placedCount();
    progress.textContent = `${placed}/${ROWS*COLS}`;
  }

  function checkSolved(){
    updateProgress();

    const placed = [...board.querySelectorAll(".piece")];
    if (placed.length !== ROWS*COLS){
      hint.textContent = `Placed ${placed.length}/${ROWS*COLS}`;
      return;
    }

    let ok = true;
    for (const p of placed){
      const correct = parseInt(p.dataset.correct, 10);
      const slot = parseInt(p.dataset.slot, 10);
      if (correct !== slot){ ok = false; break; }
    }

    if (ok){
      hint.textContent = "Perfect ‚úÖ";
      modal.classList.add("open");
      if (!solvedOnce){
        solvedOnce = true;
        startConfetti();
      }
    } else {
      hint.textContent = "Almost‚Ä¶ üôÇ";
      modal.classList.remove("open");
    }
  }

  function shuffleTray(){
    const unplaced = [...tray.querySelectorAll(".piece")];
    const s = shuffle(unplaced);
    tray.innerHTML = "";
    s.forEach(x => tray.appendChild(x));
  }

  function attachDrag(){
    pieces.forEach(p => {
      if (p.dataset.dragBound === "1") return;
      p.dataset.dragBound = "1";

      p.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        p.setPointerCapture(e.pointerId);

        isDragging = true;

        const isPlaced = (p.dataset.placed === "1");
        const fromSlot = isPlaced ? parseInt(p.dataset.slot, 10) : null;

        const startX = e.clientX, startY = e.clientY;
        const origRect = p.getBoundingClientRect();

        p.style.visibility = "hidden";

        const clone = p.cloneNode(true);
        clone.style.position = "fixed";
        clone.style.left = origRect.left + "px";
        clone.style.top = origRect.top + "px";
        clone.style.width = origRect.width + "px";
        clone.style.height = origRect.height + "px";
        clone.style.margin = "0";
        clone.style.zIndex = "9997";
        clone.style.opacity = "0.95";
        clone.style.cursor = "grabbing";
        document.body.appendChild(clone);

        const endDrag = () => { isDragging = false; };

        const move = (ev) => {
          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          clone.style.transform = `translate(${dx}px, ${dy}px)`;
        };

        const dropIntoTray = () => {
          p.dataset.placed = "0";
          p.removeAttribute("data-slot");
          p.style.position = "";
          p.style.left = "";
          p.style.top = "";
          p.style.width = "";
          p.style.height = "";
          p.style.cursor = "grab";
          p.style.visibility = "";
          tray.appendChild(p);
          modal.classList.remove("open");
          checkSolved();
        };

        const snapPieceToSlot = (pieceEl, targetIdx) => {
          const boardRect = board.getBoundingClientRect();
          const slotW = boardRect.width / COLS;
          const slotH = boardRect.height / ROWS;
          const r = Math.floor(targetIdx / COLS);
          const c = targetIdx % COLS;

          pieceEl.dataset.slot = String(targetIdx);
          pieceEl.dataset.placed = "1";

          pieceEl.style.position = "absolute";
          pieceEl.style.left = (c*slotW) + "px";
          pieceEl.style.top  = (r*slotH) + "px";
          pieceEl.style.width  = slotW + "px";
          pieceEl.style.height = slotH + "px";
          pieceEl.style.borderRadius = "14px";
          pieceEl.style.cursor = "grab";
          pieceEl.style.visibility = "";

          board.appendChild(pieceEl);
        };

        const up = (ev) => {
          p.releasePointerCapture(e.pointerId);
          window.removeEventListener("pointermove", move);
          window.removeEventListener("pointerup", up);

          const boardRect = board.getBoundingClientRect();
          const dropX = ev.clientX, dropY = ev.clientY;

          const onBoard =
            dropX >= boardRect.left && dropX <= boardRect.right &&
            dropY >= boardRect.top  && dropY <= boardRect.bottom;

          if (!onBoard){
            clone.remove();
            dropIntoTray();
            endDrag();
            return;
          }

          const localX = dropX - boardRect.left;
          const localY = dropY - boardRect.top;

          const slotW = boardRect.width / COLS;
          const slotH = boardRect.height / ROWS;

          const c = Math.max(0, Math.min(COLS-1, Math.floor(localX / slotW)));
          const r = Math.max(0, Math.min(ROWS-1, Math.floor(localY / slotH)));
          const targetIdx = r*COLS + c;

          const occupant = board.querySelector(`.piece[data-slot='${targetIdx}']`);

          if (occupant && occupant !== p){
            if (isPlaced && fromSlot !== null && fromSlot !== targetIdx){
              const backOcc = board.querySelector(`.piece[data-slot='${fromSlot}']`);
              if (!backOcc || backOcc === p){
                snapPieceToSlot(occupant, fromSlot);
              } else {
                occupant.dataset.placed = "0";
                occupant.removeAttribute("data-slot");
                occupant.style.position = "";
                occupant.style.left = "";
                occupant.style.top = "";
                occupant.style.width = "";
                occupant.style.height = "";
                occupant.style.cursor = "grab";
                tray.appendChild(occupant);
              }
            } else {
              occupant.dataset.placed = "0";
              occupant.removeAttribute("data-slot");
              occupant.style.position = "";
              occupant.style.left = "";
              occupant.style.top = "";
              occupant.style.width = "";
              occupant.style.height = "";
              occupant.style.cursor = "grab";
              tray.appendChild(occupant);
            }
          }

          snapPieceToSlot(p, targetIdx);

          clone.remove();
          modal.classList.remove("open");
          checkSolved();
          endDrag();
        };

        window.addEventListener("pointermove", move);
        window.addEventListener("pointerup", up);
      });
    });
  }

  // Confetti
  const confettiCanvas = document.getElementById("confetti");
  const ctx = confettiCanvas.getContext("2d");
  let confetti = [];
  let confettiRunning = false;

  function resizeConfetti(){
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resizeConfetti);
  resizeConfetti();

  function startConfetti(){
    if (confettiRunning) return;
    confettiRunning = true;

    confetti = Array.from({length: 160}, () => ({
      x: Math.random()*confettiCanvas.width,
      y: -20 - Math.random()*confettiCanvas.height*0.3,
      s: 3 + Math.random()*4,
      vy: 2 + Math.random()*4,
      vx: -1 + Math.random()*2,
      a: Math.random()*Math.PI*2,
      va: -0.12 + Math.random()*0.24,
      life: 160 + Math.random()*120
    }));

    requestAnimationFrame(tickConfetti);
    setTimeout(() => { confettiRunning = false; }, 2200);
  }

  function tickConfetti(){
    ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);

    for (const p of confetti){
      p.x += p.vx;
      p.y += p.vy;
      p.a += p.va;
      p.life -= 1;

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.a);

      const hue = 320 + Math.floor(Math.random()*50);
      ctx.fillStyle = `hsla(${hue}, 90%, 70%, 0.9)`;
      ctx.fillRect(-p.s, -p.s, p.s*2, p.s*2);

      ctx.restore();
    }

    confetti = confetti.filter(p => p.life > 0 && p.y < confettiCanvas.height + 40);

    if (confettiRunning || confetti.length){
      requestAnimationFrame(tickConfetti);
    } else {
      ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
    }
  }

  // Floating hearts generator
  const floatHearts = document.getElementById("floatHearts");
  const HEARTS = ["‚ù§","üíó","üíñ","üíò","üíï"];
  for(let i=0;i<14;i++){
    const h = document.createElement("div");
    h.className = "heart";
    h.textContent = HEARTS[Math.floor(Math.random()*HEARTS.length)];
    h.style.left = Math.floor(Math.random()*100) + "vw";
    h.style.animationDuration = (8 + Math.random()*8).toFixed(1) + "s";
    h.style.animationDelay = (Math.random()*6).toFixed(1) + "s";
    h.style.fontSize = (18 + Math.random()*26).toFixed(0) + "px";
    h.style.opacity = (0.12 + Math.random()*0.18).toFixed(2);
    floatHearts.appendChild(h);
  }

  document.getElementById("shuffleBtn").addEventListener("click", shuffleTray);
  document.getElementById("restartBtn").addEventListener("click", init);
  document.getElementById("guideBtn").addEventListener("click", () => {
    showGuide = !showGuide;
    [...board.querySelectorAll(".ghostSlot")].forEach(s => s.style.opacity = showGuide ? "1" : "0");
  });

  function init(){
    clearAll();
    makeSlots();
    updateTrayPieceSize();
    createPieces();
  }

  const preload = new Image();
  preload.onload = () => init();
  preload.onerror = () => {
    hint.textContent = "Image not loading. Ensure it's named puzzle.jpg and in the same folder as index.html.";
  };
  preload.src = IMAGE_SRC;
</script>
</body>
</html>
