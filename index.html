<!doctype html>
<html lang="ar">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Valentine Puzzle</title>

  <style>
    :root{
      --text:#e9eefc;
      --muted:rgba(233,238,252,0.78);
      --card:rgba(255,255,255,0.08);
      --border:rgba(255,255,255,0.15);
      --shadow:0 25px 70px rgba(0,0,0,0.5);
      --accent:#ff4d7d;

      /* tray piece size set by JS */
      --trayW: 66px;
      --trayH: 110px;
    }

    /* ====== LOCK SCROLL / PULL-TO-REFRESH (strong) ====== */
    html, body{
      height: 100%;
      overflow: hidden;              /* no page scrolling */
      overscroll-behavior: none;      /* no pull-to-refresh */
    }
    body{
      position: fixed;               /* keep viewport fixed */
      width: 100%;
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:var(--text);
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(900px 600px at 20% 10%, rgba(255,77,125,0.25), transparent 60%),
        radial-gradient(900px 700px at 80% 90%, rgba(255,179,199,0.18), transparent 60%),
        linear-gradient(180deg,#0b0f19,#1a1030);
    }

    /* While playing, don't let browser interpret gestures as scrolling */
    #board, #tray, .piece{ touch-action: none; }

    #confetti{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:9998;
    }

    .card{
      width:min(1040px,95vw);
      max-height: 94vh;              /* keep inside viewport */
      overflow: hidden;              /* avoid internal scroll bounce */
      background:var(--card);
      border:1px solid var(--border);
      border-radius:22px;
      padding:20px;
      box-shadow:var(--shadow);
      backdrop-filter:blur(12px);
      box-sizing: border-box;
    }

    .top{
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom:12px;
    }

    .brand{
      display:flex;
      gap:10px;
      align-items:center;
    }

    .badge{
      width:40px;height:40px;
      border-radius:14px;
      display:grid;place-items:center;
      background:rgba(255,77,125,0.18);
      border:1px solid rgba(255,77,125,0.35);
      box-shadow:0 10px 30px rgba(255,77,125,0.12);
      font-size:18px;
    }

    h1{ margin:0 0 4px; font-size:18px; }
    p{ margin:0; color:var(--muted); line-height:1.6; }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin:12px 0 14px;
    }

    .btn{
      padding:10px 14px;
      border-radius:14px;
      font-weight:800;
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.20);
      background:rgba(255,255,255,0.10);
      color:var(--text);
      transition:transform .08s ease, background .2s ease;
    }
    .btn:hover{ background:rgba(255,255,255,0.16); }
    .btn:active{ transform:scale(0.98); }

    .btn.primary{
      background:rgba(255,77,125,0.18);
      border-color:rgba(255,77,125,0.35);
    }
    .btn.primary:hover{ background:rgba(255,77,125,0.24); }

    .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:14px;
      align-items:start;
    }
    @media(max-width:860px){ .grid{ grid-template-columns:1fr; } }

    .panel{
      background:rgba(0,0,0,0.25);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:18px;
      padding:12px;
      box-sizing: border-box;
    }

    .title{
      font-size:13px;
      color:rgba(233,238,252,0.72);
      margin:0 0 10px;
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    .progress{
      font-size:12px;
      color:rgba(233,238,252,0.70);
    }

    /* Board */
    #board{
      position:relative;
      width:100%;
      aspect-ratio: 9 / 16;
      border-radius:16px;
      overflow:hidden;
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.15);
    }

    /* Tray */
    #tray{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      min-height:120px;
      align-content:flex-start;
    }

    /* Pieces */
    .piece{
      width: var(--trayW);
      height: var(--trayH);
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.20);
      background-image: var(--img);
      background-size: var(--bgSize);
      background-position: var(--bgPos);
      cursor:grab;
      user-select:none;
      box-shadow:0 10px 25px rgba(0,0,0,0.20);
      transition:transform .12s ease, box-shadow .2s ease, border-color .2s ease;
    }
    .piece:hover{
      transform:translateY(-1px);
      border-color:rgba(255,255,255,0.30);
      box-shadow:0 14px 35px rgba(0,0,0,0.28);
    }
    .piece:active{ cursor:grabbing; transform:scale(0.99); }

    .ghostSlot{
      position:absolute;
      border:1px dashed rgba(255,255,255,0.18);
      border-radius:14px;
      pointer-events:none;
    }

    .hint{
      margin-top:8px;
      font-size:13px;
      color:rgba(233,238,252,0.75);
    }

    .tiny{
      margin-top:10px;
      font-size:12px;
      color:rgba(233,238,252,0.55);
      line-height:1.5;
    }

    /* Modal */
    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      background:rgba(0,0,0,0.60);
      backdrop-filter:blur(6px);
      z-index:9999;
    }
    .modal.open{ display:flex; }

    .modalCard{
      width:min(560px,92vw);
      background:rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.20);
      border-radius:20px;
      box-shadow:var(--shadow);
      padding:16px;
    }

    .modalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .modalTop h2{ margin:0; font-size:16px; }

    .close{
      background:rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.16);
      color:var(--text);
      border-radius:12px;
      padding:8px 10px;
      cursor:pointer;
      font-weight:800;
    }

    .msg{
      white-space:pre-wrap;
      color:rgba(233,238,252,0.92);
      line-height:1.7;
    }
  </style>
</head>

<body>
  <canvas id="confetti"></canvas>

  <div class="card">
    <div class="top">
      <div class="brand">
        <div class="badge">ğŸ’˜</div>
        <div>
          <h1>Ø¨Ø§Ø²Ù„ ØµØºÙŠØ±â€¦ ÙˆÙ…ÙØ§Ø¬Ø£Ø©</h1>
          <p>Ø±ÙƒÙ‘Ø¨ Ø§Ù„ØµÙˆØ±Ø©. Ø£ÙˆÙ„ Ù…Ø§ ØªØ¸Ø¨Ø·â€¦ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù‡ØªØ¸Ù‡Ø± Ù„ÙˆØ­Ø¯Ù‡Ø§.</p>
        </div>
      </div>
    </div>

    <div class="row">
      <button class="btn primary" id="shuffleBtn">Shuffle</button>
      <button class="btn" id="restartBtn">Restart</button>
      <button class="btn" id="guideBtn">Toggle Guide</button>
    </div>

    <div class="grid">
      <div class="panel">
        <div class="title">
          <span>Board</span>
          <span class="progress" id="progress">0/16</span>
        </div>
        <div id="board"></div>
        <div class="hint" id="hint"></div>
      </div>

      <div class="panel">
        <div class="title"><span>Pieces tray</span></div>
        <div id="tray"></div>
        <div class="tiny">ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù€ pull-to-refresh Ù†Ù‡Ø§Ø¦ÙŠÙ‹Ø§. (Ø§Ù„ØµÙØ­Ø© Ø¨Ø¯ÙˆÙ† scroll)</div>
      </div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="modalCard">
      <div class="modalTop">
        <h2>Unlocked ğŸ’Œ</h2>
        <button class="close" id="closeModal">Close</button>
      </div>
      <div class="msg" id="modalMsg"></div>
    </div>
  </div>

<script>
  /* ====== Settings ====== */
  const IMAGE_SRC = "puzzle.jpg";
  const ROWS = 4;
  const COLS = 4;

  const finalMessage =
`Happy Valentineâ€™s Day, Emily ğŸŒ¹

Some sunsets are beautifulâ€¦
but this one is yours.

â€” Girgis`;
  /* ====================== */

  const board = document.getElementById("board");
  const tray = document.getElementById("tray");
  const hint = document.getElementById("hint");
  const progress = document.getElementById("progress");

  const modal = document.getElementById("modal");
  const modalMsg = document.getElementById("modalMsg");
  const closeModal = document.getElementById("closeModal");
  modalMsg.textContent = finalMessage;

  closeModal.addEventListener("click", () => modal.classList.remove("open"));
  modal.addEventListener("click", (e) => { if (e.target === modal) modal.classList.remove("open"); });

  const IMG = `url('${IMAGE_SRC}')`;

  let pieces = [];
  let showGuide = true;
  let solvedOnce = false;

  // ===== Ultra-strong prevent refresh on mobile =====
  // Prevent any touchmove from scrolling/refreshing the page.
  document.addEventListener("touchmove", (e) => {
    e.preventDefault();
  }, { passive: false });

  // Prevent touchstart default on play areas (helps some browsers)
  board.addEventListener("touchstart", (e) => e.preventDefault(), { passive: false });
  tray.addEventListener("touchstart", (e) => e.preventDefault(), { passive: false });

  function shuffle(arr){
    const a = [...arr];
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function clearAll(){
    board.innerHTML = "";
    tray.innerHTML = "";
    pieces = [];
    modal.classList.remove("open");
    solvedOnce = false;
  }

  function makeSlots(){
    const rect = board.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;
    const slotW = W / COLS;
    const slotH = H / ROWS;

    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const s = document.createElement("div");
        s.className = "ghostSlot";
        s.style.left = (c*slotW) + "px";
        s.style.top  = (r*slotH) + "px";
        s.style.width  = slotW + "px";
        s.style.height = slotH + "px";
        s.style.opacity = showGuide ? "1" : "0";
        board.appendChild(s);
      }
    }
  }

  function updateTrayPieceSize(){
    const boardRect = board.getBoundingClientRect();
    const slotW = boardRect.width / COLS;
    const slotH = boardRect.height / ROWS;

    const scale = 0.58;
    const trayW = Math.max(48, Math.floor(slotW * scale));
    const trayH = Math.max(70, Math.floor(slotH * scale));

    document.documentElement.style.setProperty("--trayW", trayW + "px");
    document.documentElement.style.setProperty("--trayH", trayH + "px");
  }

  function createPieces(){
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const correctIdx = r*COLS + c;
        const d = document.createElement("div");
        d.className = "piece";
        d.dataset.correct = String(correctIdx);
        d.dataset.placed = "0";
        d.style.setProperty("--img", IMG);
        d.style.setProperty("--bgSize", `${COLS*100}% ${ROWS*100}%`);

        const posX = (c/(COLS-1||1))*100;
        const posY = (r/(ROWS-1||1))*100;
        d.style.setProperty("--bgPos", `${posX}% ${posY}%`);

        pieces.push(d);
      }
    }

    pieces = shuffle(pieces);
    pieces.forEach(p => tray.appendChild(p));
    attachDrag();
    updateProgress();
    hint.textContent = "Ø§Ø¨Ø¯Ø£â€¦ ÙˆØ±ØªÙ‘Ø¨Ù‡Ø§ ÙˆØ§Ø­Ø¯Ø© ÙˆØ§Ø­Ø¯Ø© ğŸ™‚";
  }

  function placedCount(){
    return board.querySelectorAll(".piece").length;
  }

  function updateProgress(){
    const placed = placedCount();
    progress.textContent = `${placed}/${ROWS*COLS}`;
  }

  function checkSolved(){
    updateProgress();

    const placed = [...board.querySelectorAll(".piece")];
    if (placed.length !== ROWS*COLS){
      hint.textContent = `Ù…ØªØ­Ø·Ù‘Ø· ${placed.length}/${ROWS*COLS}.`;
      return;
    }

    let ok = true;
    for (const p of placed){
      const correct = parseInt(p.dataset.correct, 10);
      const slot = parseInt(p.dataset.slot, 10);
      if (correct !== slot){ ok = false; break; }
    }

    if (ok){
      hint.textContent = "Perfect âœ…";
      modal.classList.add("open");
      if (!solvedOnce){
        solvedOnce = true;
        startConfetti();
      }
    } else {
      hint.textContent = "Ù‚Ø±Ø¨Øªâ€¦ ÙÙŠ Ù‚Ø·Ø¹ Ù…ØªØ¨Ø¯Ù„Ø© ğŸ™‚";
      modal.classList.remove("open");
    }
  }

  function shuffleTray(){
    const unplaced = [...tray.querySelectorAll(".piece")];
    const s = shuffle(unplaced);
    tray.innerHTML = "";
    s.forEach(x => tray.appendChild(x));
  }

  function attachDrag(){
    pieces.forEach(p => {
      if (p.dataset.dragBound === "1") return;
      p.dataset.dragBound = "1";

      p.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        p.setPointerCapture(e.pointerId);

        const isPlaced = (p.dataset.placed === "1");
        const fromSlot = isPlaced ? parseInt(p.dataset.slot, 10) : null;

        const startX = e.clientX, startY = e.clientY;
        const origRect = p.getBoundingClientRect();

        p.style.visibility = "hidden";

        const clone = p.cloneNode(true);
        clone.style.position = "fixed";
        clone.style.left = origRect.left + "px";
        clone.style.top = origRect.top + "px";
        clone.style.width = origRect.width + "px";
        clone.style.height = origRect.height + "px";
        clone.style.margin = "0";
        clone.style.zIndex = "9997";
        clone.style.opacity = "0.95";
        clone.style.cursor = "grabbing";
        document.body.appendChild(clone);

        const move = (ev) => {
          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          clone.style.transform = `translate(${dx}px, ${dy}px)`;
        };

        const dropIntoTray = () => {
          p.dataset.placed = "0";
          p.removeAttribute("data-slot");
          p.style.position = "";
          p.style.left = "";
          p.style.top = "";
          p.style.width = "";
          p.style.height = "";
          p.style.cursor = "grab";
          p.style.visibility = "";
          tray.appendChild(p);
          modal.classList.remove("open");
          checkSolved();
        };

        const snapPieceToSlot = (pieceEl, targetIdx) => {
          const boardRect = board.getBoundingClientRect();
          const slotW = boardRect.width / COLS;
          const slotH = boardRect.height / ROWS;
          const r = Math.floor(targetIdx / COLS);
          const c = targetIdx % COLS;

          pieceEl.dataset.slot = String(targetIdx);
          pieceEl.dataset.placed = "1";

          pieceEl.style.position = "absolute";
          pieceEl.style.left = (c*slotW) + "px";
          pieceEl.style.top  = (r*slotH) + "px";
          pieceEl.style.width  = slotW + "px";
          pieceEl.style.height = slotH + "px";
          pieceEl.style.borderRadius = "14px";
          pieceEl.style.cursor = "grab";
          pieceEl.style.visibility = "";

          board.appendChild(pieceEl);
        };

        const up = (ev) => {
          p.releasePointerCapture(e.pointerId);
          window.removeEventListener("pointermove", move);
          window.removeEventListener("pointerup", up);

          const boardRect = board.getBoundingClientRect();
          const dropX = ev.clientX, dropY = ev.clientY;

          const onBoard =
            dropX >= boardRect.left && dropX <= boardRect.right &&
            dropY >= boardRect.top  && dropY <= boardRect.bottom;

          if (!onBoard){
            clone.remove();
            dropIntoTray();
            return;
          }

          const localX = dropX - boardRect.left;
          const localY = dropY - boardRect.top;

          const slotW = boardRect.width / COLS;
          const slotH = boardRect.height / ROWS;

          const c = Math.max(0, Math.min(COLS-1, Math.floor(localX / slotW)));
          const r = Math.max(0, Math.min(ROWS-1, Math.floor(localY / slotH)));
          const targetIdx = r*COLS + c;

          const occupant = board.querySelector(`.piece[data-slot='${targetIdx}']`);

          if (occupant && occupant !== p){
            if (isPlaced && fromSlot !== null && fromSlot !== targetIdx){
              const backOcc = board.querySelector(`.piece[data-slot='${fromSlot}']`);
              if (!backOcc || backOcc === p){
                snapPieceToSlot(occupant, fromSlot);
              } else {
                occupant.dataset.placed = "0";
                occupant.removeAttribute("data-slot");
                occupant.style.position = "";
                occupant.style.left = "";
                occupant.style.top = "";
                occupant.style.width = "";
                occupant.style.height = "";
                occupant.style.cursor = "grab";
                tray.appendChild(occupant);
              }
            } else {
              occupant.dataset.placed = "0";
              occupant.removeAttribute("data-slot");
              occupant.style.position = "";
              occupant.style.left = "";
              occupant.style.top = "";
              occupant.style.width = "";
              occupant.style.height = "";
              occupant.style.cursor = "grab";
              tray.appendChild(occupant);
            }
          }

          snapPieceToSlot(p, targetIdx);

          clone.remove();
          modal.classList.remove("open");
          checkSolved();
        };

        window.addEventListener("pointermove", move);
        window.addEventListener("pointerup", up);
      });
    });
  }

  /* Confetti */
  const confettiCanvas = document.getElementById("confetti");
  const ctx = confettiCanvas.getContext("2d");
  let confetti = [];
  let confettiRunning = false;

  function resizeConfetti(){
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resizeConfetti);
  resizeConfetti();

  function startConfetti(){
    if (confettiRunning) return;
    confettiRunning = true;

    confetti = Array.from({length: 160}, () => ({
      x: Math.random()*confettiCanvas.width,
      y: -20 - Math.random()*confettiCanvas.height*0.3,
      s: 3 + Math.random()*4,
      vy: 2 + Math.random()*4,
      vx: -1 + Math.random()*2,
      a: Math.random()*Math.PI*2,
      va: -0.12 + Math.random()*0.24,
      life: 160 + Math.random()*120
    }));

    requestAnimationFrame(tickConfetti);
    setTimeout(() => { confettiRunning = false; }, 2200);
  }

  function tickConfetti(){
    ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);

    for (const p of confetti){
      p.x += p.vx;
      p.y += p.vy;
      p.a += p.va;
      p.life -= 1;

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.a);

      const hue = 320 + Math.floor(Math.random()*50);
      ctx.fillStyle = `hsla(${hue}, 90%, 70%, 0.9)`;
      ctx.fillRect(-p.s, -p.s, p.s*2, p.s*2);

      ctx.restore();
    }

    confetti = confetti.filter(p => p.life > 0 && p.y < confettiCanvas.height + 40);

    if (confettiRunning || confetti.length){
      requestAnimationFrame(tickConfetti);
    } else {
      ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
    }
  }

  /* Buttons */
  document.getElementById("shuffleBtn").addEventListener("click", shuffleTray);
  document.getElementById("restartBtn").addEventListener("click", init);
  document.getElementById("guideBtn").addEventListener("click", () => {
    showGuide = !showGuide;
    [...board.querySelectorAll(".ghostSlot")].forEach(s => s.style.opacity = showGuide ? "1" : "0");
  });

  function init(){
    clearAll();
    makeSlots();
    updateTrayPieceSize();
    createPieces();
  }

  window.addEventListener("resize", () => {
    clearTimeout(window.__rz);
    window.__rz = setTimeout(init, 250);
  });

  const preload = new Image();
  preload.onload = () => init();
  preload.onerror = () => {
    hint.textContent = "Ø§Ù„ØµÙˆØ±Ø© Ù…Ø´ Ø¨ØªØªØ­Ù…Ù„. ØªØ£ÙƒØ¯ Ø¥Ù†Ù‡Ø§ Ø§Ø³Ù…Ù‡Ø§ puzzle.jpg ÙˆÙÙŠ Ù†ÙØ³ Ù…ÙƒØ§Ù† index.html.";
  };
  preload.src = IMAGE_SRC;
</script>
</body>
</html>
